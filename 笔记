CH1:
1.指针类型 =》 指针类型的变量/指针类型的值
2.指针类型的值 =》 内存的地址
3.空字符：所有位为0的字节  ('\0')
    区分(0,'\0',NULL): #define NULL (void*) 0
    在不同系统中NULL的定义并非都是0
    0在c语言中“编译器根据上下文判断”，得到  空指针or常量
4.下标运算符[]和数组是没有关系的
  p = array
    *(p + i) 等于  p[i]
    由于*(p + i) 等于 *(i + p), 所以 p[i] 等于 i[p] 好特么神奇


CH2:
1.在如今的运行环境中，应用程序面对的是虚拟地址空间
2.存储类型修饰符：typedef extern static auto register
3.内存图：
  函数，字符串常量
  静态变量（函数内的static变量，文件内的static变量，全局变量）
  利用malloc分配的内存区域
  |
  |离得很远
  |
  自动变量
4.函数和字符串常量
  配置在只读内存区域
5.指向函数的指针
  int func(double d);
  int (*func_p)(double);
  func_p = func;
  func_p(0.5);
  -----------------
  int (*func_table[])(double) = {
    func0,
    func1,
    func2,
    func3
  };
6.静态变量
  源代码文件 =》 编译器 =》目标代码 =》 链接器 =》 可执行程序
  符号表：
    C => 全局变量
    b => static(后面追加.4是为了防止局部static变量的名称重复)
    T => 函数在当前文件定义
    U => 函数在外部定义
7.自动变量(栈)
8.malloc不是系统调用,无法回避碎片问题
9.realloc
  p = realloc(p,size) p可以为NULL或者非NULL
  realloc(p,0) == free(p)

CH3
1.声明的解读
2.指针，数组，函数类型派生
3.C的类型分为：对象类型，函数类型和不完全类型（void类型）
4.对象类型：有特定长度的类型，比如数组，指针，基本类型
5.函数类型不是对象类型，因为没有特定长度，所以没有“函数的数组”，也无法做函数指针的运算
6.表达式：
  基本表达式：
    标识符（变量名，函数名）
    常量（包括整数常量和浮点数常量）
    字符串常量（使用“”括起来的字符串）
    使用（）括起来的表达式
7.常量 != 只读
8.函数调用运算符()的操作数不是“函数”，而是”函数的指针“
